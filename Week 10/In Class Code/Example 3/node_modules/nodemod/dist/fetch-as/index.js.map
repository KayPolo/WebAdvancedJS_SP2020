{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/fetch-as/index.ts"],"names":[],"mappings":"AAiBA,SAAS,kBAAkB,CAAC,OAAgB;IAC1C,MAAM,CAAC,GAAkB,EAAE,CAAC;IAE5B,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,EAAE;QAC5B,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;KACV;IAED,OAAO,CAAC,CAAC;AACX,CAAC;AAED,SAAS,OAAO,CAAO,SAAoB;IAIzC,OAAO,KAAK,EAAE,GAAW,EAAE,OAAqB,EAAoC,EAAE;QACpF,IAAI,MAAM,GAAG,CAAC,CAAC,CAAC;QAChB,IAAI,OAAO,GAAkB,EAAE,CAAC;QAChC,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC;QACd,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC;QACjB,IAAI,IAAI,GAAiB,OAAO,CAAC;QAEjC,IAAI;YACF,MAAM,CAAC,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YACpC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC;YAE/B,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;YAClB,OAAO,GAAG,kBAAkB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;YACxC,IAAI,GAAI,CAA2B,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;YAC/C,OAAO,GAAI,CAA2B,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC;YACrD,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC;YAEd,OAAO;gBACL,MAAM;gBACN,IAAI,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE;gBACtC,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC;aACrC,CAAC;SACH;QAAC,OAAO,CAAC,EAAE;YACV,OAAO;gBACL,MAAM;gBACN,IAAI,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE;gBACtC,KAAK,EAAE,CAAC;aACT,CAAC;SACH;IACH,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,kBAAkB,CACtC,GAAW,EAAE,OAAqB;IAClC,OAAO,OAAO,CAAO,aAAa,CAAC,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AACpD,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,WAAW,CAC/B,GAAW,EAAE,OAAqB;IAClC,OAAO,OAAO,CAAO,MAAM,CAAC,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC7C,CAAC;AAOD,MAAM,CAAC,KAAK,UAAU,WAAW,CAAiB,GAAW,EAAE,OAAqB;IAClF,OAAO,OAAO,CAAO,MAAM,CAAC,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC7C,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,WAAW,CAC/B,GAAW,EAAE,OAAqB;IAClC,OAAO,OAAO,CAAO,MAAM,CAAC,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC7C,CAAC;AAOD,eAAe;IACb,WAAW,EAAE,kBAAkB;IAC/B,IAAI,EAAE,WAAW;IAEjB,IAAI,EAAE,WAAW;IACjB,IAAI,EAAE,WAAW;CAElB,CAAC","sourcesContent":["import type {\n  ExtendedFetchResponse,\n  FetchAsReturnType,\n  FetchType,\n  UnknownRecord,\n} from './custom_typings.js';\n\n// import {\n//   Blob,\n//   Body,\n//   Headers,\n//   RequestInit,\n//   Response,\n// } from 'node-fetch';\n\n// import fetch from 'node-fetch';\n\nfunction getResponseHeaders(headers: Headers) {\n  const d: UnknownRecord = {};\n\n  for (const [k, v] of headers) {\n    d[k] = v;\n  }\n\n  return d;\n}\n\nfunction fetchAs<T, U>(fetchType: FetchType): (\n  url: string,\n  options?: RequestInit\n) => Promise<FetchAsReturnType<T, U>> {\n  return async (url: string, options?: RequestInit): Promise<FetchAsReturnType<T, U>> => {\n    let status = -1;\n    let headers: UnknownRecord = {};\n    let size = -1;\n    let timeout = -1;\n    let type: ResponseType = 'basic';\n\n    try {\n      const r = await fetch(url, options);\n      const d = await r[fetchType]();\n\n      status = r.status;\n      headers = getResponseHeaders(r.headers);\n      size = (r as ExtendedFetchResponse).size || -1;\n      timeout = (r as ExtendedFetchResponse).timeout || -1;\n      type = r.type;\n\n      return {\n        status,\n        info: { headers, size, timeout, type },\n        [status > 399 ? 'error' : 'data']: d,\n      };\n    } catch (e) {\n      return {\n        status,\n        info: { headers, size, timeout, type },\n        error: e,\n      };\n    }\n  };\n}\n\nexport async function fetchAsArrayBuffer<T = ArrayBuffer, U = ArrayBuffer>(\n  url: string, options?: RequestInit) {\n  return fetchAs<T, U>('arrayBuffer')(url, options);\n}\n\nexport async function fetchAsBlob<T = Blob, U = Blob>(\n  url: string, options?: RequestInit) {\n  return fetchAs<T, U>('blob')(url, options);\n}\n\n// export async function fetchAsBuffer<T = Buffer, U = Buffer>(\n//   url: string, options?: RequestInit) {\n//   return fetchAs<T, U>('buffer')(url, options);\n// }\n\nexport async function fetchAsJson<T = {}, U = {}>(url: string, options?: RequestInit) {\n  return fetchAs<T, U>('json')(url, options);\n}\n\nexport async function fetchAsText<T = string, U = any>(\n  url: string, options?: RequestInit) {\n  return fetchAs<T, U>('text')(url, options);\n}\n\n// export async function fetchAsTextConverted<T = string, U = any>(\n//   url: string, options?: RequestInit) {\n//   return fetchAs<T, U>('textConverted')(url, options);\n// }\n\nexport default {\n  arrayBuffer: fetchAsArrayBuffer,\n  blob: fetchAsBlob,\n  // buffer: fetchAsBuffer,\n  json: fetchAsJson,\n  text: fetchAsText,\n  // textConverted: fetchAsTextConverted,\n};\n"]}